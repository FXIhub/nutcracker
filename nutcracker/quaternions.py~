def compare_two_sets_of_quaternions(q1,q2,full_output=False,n_samples=100,q1_is_extrinsic=False,q2_is_extrinsic=False,sigma=2):
    """
    Compares two sets of quaternions based on a comparison of randomly picked quaternions within each set. 

    Args: 
        :q1(float ndarray):        5d ndarray of intrinsic quaternions
        :q2(float ndarray):        5d ndarray of intrinsic quaternions

    Kwargs:
        :full_output(bool):        returns full output as a dictionary, default = False
        :n_samples(int):           number of randomly picked pairs of quaternions, default = 100
        :q1_is_extrinsic(bool):    q1 quaternions are extrinsic and should be converted to instrinsic, default = False
        :q2_is_extrinsic(bool):    q2 quaternions are extrinsic and should be converted to instrinsic, default = False 
        :sigma(int):               sigma of standart deviation, default = 2
    """

    q1_rel_list = []
    q2_rel_list = []
    
    # iterate through a number of randomly picked pairs
    for i in range(n_samples):
        
        # pick random index
        m = np.random.randint(0,q1.shape[0])
        n = np.random.randint(0,q1.shape[0])
        
        # make sure m and n are not the same
        if m == n: n = q1.shape[0] - n
        
        # pick random quaternions and make sure they are represented on one half of the hyper sphere
        q1_m = condor.utils.rotation.unique_representation_quat(q1[m,:])
        q1_n = condor.utils.rotation.unique_representation_quat(q1[n,:])
        q2_m = condor.utils.rotation.unique_representation_quat(q2[m,:])
        q2_n = condor.utils.rotation.unique_representation_quat(q2[n,:])

        # normalise quaternions
        q1_m = q1_m/np.sqrt(q1_m[0]**2 + q1_m[1]**2 + q1_m[2]**2 + q1_m[3]**2)
        q1_n = q1_n/np.sqrt(q1_n[0]**2 + q1_n[1]**2 + q1_n[2]**2 + q1_n[3]**2)
        q2_m = q2_m/np.sqrt(q2_m[0]**2 + q2_m[1]**2 + q2_m[2]**2 + q2_m[3]**2)
        q2_n = q2_n/np.sqrt(q2_n[0]**2 + q2_n[1]**2 + q2_n[2]**2 + q2_n[3]**2)
    
        # convert quaternions if necessary
        if q1_is_extrinsic: 
            q1_m = condor.utils.roation.quat_conj(q1_m)
            q1_n = condor.utils.roation.quat_conj(q1_n)
        if q2_is_extrinsic: 
            q2_m = condor.utils.roation.quat_conj(q2_m)
            q2_n = condor.utils.roation.quat_conj(q2_n)

        # calculating the inverse of q_i -> q_1^-1
        q1_n_inv = condor.utils.rotation.quat_conj(q1_n)/(np.sqrt(q1_n[0]**2 + q1_n[1]**2 + q1_n[2]**2 + q1_n[3]**2)**2)
        q2_n_inv = condor.utils.rotation.quat_conj(q2_n)/(np.sqrt(q2_n[0]**2 + q2_n[1]**2 + q2_n[2]**2 + q2_n[3]**2)**2)
    
        # calculating the relative quaternion q_rel = q_0 * q_i^-1
        q1_rel = condor.utils.rotation.quat_mult(q1_m, q1_n_inv)
        w1 = q1_rel[0]

        # calculating the relative quaternion q_rel = q_0 * q_i^-1 
        q2_rel_1 = condor.utils.rotation.quat_mult(q2_m, q2_n_inv)
        q2_rel_2 = condor.utils.rotation.quat_mult(q2_m, -1 * q2_n_inv)
        w2_1 = q2_rel_1[0]
        w2_2 = q2_rel_2[0]
        if np.abs(w1 - w2_1) < np.abs(w1 - w2_2): 
            w2 = w2_1
            q2_rel = q2_rel_1
        else:
            w2 = w2_2
            q2_rel = q2_rel_2
            
        q1_rel_list.append(q1_rel)
        q2_rel_list.append(q2_rel)
    
    q1_rel_array = np.array(q1_rel_list)
    q2_rel_array = np.array(q2_rel_list)

    # angle between the two relative quaternions 
    theta_rel = 2 * np.arccos(np.inner(q1_rel_array,q2_rel_array))
        
    # difference between scalar components of two relative quaternions
    diff_rel = q1_rel_array[:,0] - q2_rel_array[:,0]
    diff_rel_mean = diff_rel.mean()
    diff_rel_std = diff_rel.std()

    # calculate z-score
    z_score = (diff_rel - diff_rel_mean)/diff_rel_std
    
    # percentage of quaternions within given sigma
    p = (z_score < sigma).sum()/q1.shape[0]

    if full_output:
        out = {'q1_rel':q1_rel_array,
               'q1_rel':q2_rel_array,
               'theta_rel':theta_rel,
               'diff_rel':diff_rel,
               'z_score':z_score}
        return p,out
    else:
        return p
